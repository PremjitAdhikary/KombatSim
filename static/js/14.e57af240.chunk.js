(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{37:function(e,n,a){"use strict";var t=a(0),l=a.n(t),o=a(6),r=a(1),i=(a(38),function(e,n){return e?l.a.createElement(o.c,{className:"btn",to:Object(r.b)(e).path},n):l.a.createElement("span",{className:"btn-disabled"},n)});n.a=function(e){return l.a.createElement("div",{className:"navs"},l.a.createElement("span",{className:"left"},i(e.prev,"Previous")),l.a.createElement("span",{className:"right"},i(e.next,"Next")))}},38:function(e,n,a){},39:function(e,n,a){"use strict";var t=a(8),l=a(0),o=a.n(l),r=(a(40),["abstract","assert","boolean","break","byte","case","catch","char","class","const","do","double","else","enum","extends","final","finally","float","for","goto","if","implements","import","instanceof","int","interface","long","native","new","package","private","protected","public","return","short","static","strictfp","super","switch","synchronized","this","throw","throws","transient","try","void","volatile","while","true","false","null"]),i=["Override"],c=function(e){return e=function(e){var n=e,a=n.match(/\/\*[\s\S]*?\*\/|([^:]|^)\/\/.*$/gm);if(a){var l=Object(t.a)(a);l.forEach(function(e){return n=n.replace(e,'<span style="color: lightgray; font-style: italic;">'+e+"</span>")})}return n}(e=function(e){var n=e;return i.forEach(function(e){return n=n.replace(new RegExp("@\\b"+e+"\\b","g"),'<span style="color: lightgray; font-weight: bold;">@'+e+"</span>")}),n}(e=function(e){var n=e;return r.forEach(function(e){return n=n.replace(new RegExp("\\b"+e+"\\b","g"),'<span style="color: yellow; font-weight: bold;">'+e+"</span>")}),n}(e)))};n.a=function(e){var n={__html:"<pre>"+c(e.code)+"</pre>"};return o.a.createElement("div",{dangerouslySetInnerHTML:n})}},40:function(e,n,a){},65:function(e,n,a){"use strict";a.r(n);var t=a(0),l=a.n(t),o=a(37),r=a(39),i=a(6),c=a(1);n.default=function(){return l.a.createElement("div",{className:"main"},l.a.createElement("div",{className:"pageTitle"},"Building Restrictions"),l.a.createElement("p",null,"This section expands upon the previous one."),l.a.createElement("p",null,"Expands more on the Builder side that is. Not much to do with lambda!"),l.a.createElement("p",null,"You can skip if you want to."),l.a.createElement("p",null,l.a.createElement("em",null,"Still here?")),l.a.createElement("p",null,"Alright then!"),l.a.createElement("p",null,"Let's take a look into the Function 'weapon' from the section ",l.a.createElement(i.b,{to:Object(c.b)("lambdaDecorator").path},"Compose/Decorate"),"."),l.a.createElement(r.a,{code:'\n\n  Function&lt;Fighter, FighterDecorator&gt; weapon = baseFighter -> {\n    FighterDecorator fighterWithSword = new Weapon(baseFighter);\n    fighterWithSword.setName("Broad Sword");\n    fighterWithSword.buildAndAddWeaponCommand(new WeaponCommand("Slash", slashDamage));\n    fighterWithSword.buildAndAddWeaponCommand(new WeaponCommand("Cut", cutDamage));\n    fighterWithSword.replaceActions();\n    fighterWithSword.equip();\n    return fighterWithSword;\n  };\n\n'}),l.a.createElement("p",null,"A couple of points pop out:",l.a.createElement("ul",null,l.a.createElement("li",null,l.a.createElement("em",null,"baseFighter")," and weapon name are mandatory."),l.a.createElement("li",null,"At least 1 ",l.a.createElement("code",null,"WeaponCommand")," must be added."),l.a.createElement("li",null,"Call to ",l.a.createElement("code",null,"FighterDecorator.equip()")," is mandatory at the end."),l.a.createElement("li",null,l.a.createElement("code",null,"buildAndAddWeaponCommand()")," is passed a 'freshly constructed' ",l.a.createElement("code",null,"WeaponCommand"),". Leads to the same problem - 'to look into documentation for what goes in a constructor'"))),l.a.createElement("p",null,"From the above list, two of them can be sorted out."),l.a.createElement("p",null,"Check for the presence of 'at least 1 ",l.a.createElement("code",null,"WeaponCommand"),"' and calling ",l.a.createElement("code",null,"FighterDecorator.equip()"),", both can be handled in ",l.a.createElement("code",null,"build()"),"."),l.a.createElement("p",null,"What if we can guide the client for the rest? What if we could restrict the path of the fluent api? Something like below..."),l.a.createElement(r.a,{code:'\n\n  FighterDecorator fighterWithSword = Weapon.create( sword -> \n    sword\n      .name("Broad Sword")\n      .wielder(baseFighter)\n      .addCommand()\n      .withName("Slash")\n      .andMove(slashDamage)\n      .addCommand()\n      .withName("Cut")\n      .andMove(cutDamage)\n      .replaceActions()\n  );\n\n'}),l.a.createElement("p",null,"Here the builder drives you:",l.a.createElement("ul",null,l.a.createElement("li",null,"At ",l.a.createElement("code",null,"sword.")," the only api exposed is ",l.a.createElement("code",null,"name()")),l.a.createElement("li",null,"Once ",l.a.createElement("code",null,"name()")," is set, only api exposed is ",l.a.createElement("code",null,"wielder()")),l.a.createElement("li",null,"At this point you have options to:",l.a.createElement("ul",null,l.a.createElement("li",null,l.a.createElement("code",null,"addCommand()")," - to add a ",l.a.createElement("code",null,"WeaponCommand"),". If this path is taken..",l.a.createElement("ul",null,l.a.createElement("li",null,"The next api exposed is ",l.a.createElement("code",null,"withName()")),l.a.createElement("li",null,"Then ",l.a.createElement("code",null,"andMove()")," is exposed"),l.a.createElement("li",null,"Back to options"))),l.a.createElement("li",null,l.a.createElement("code",null,"replaceActions()")," - to use only ",l.a.createElement("code",null,"WeaponCommand"),"s for attacks"))))),l.a.createElement("p",null,"Cool!"),l.a.createElement("p",null,l.a.createElement("em",null,"But how?")),l.a.createElement("p",null,"A lot of code actually..."),l.a.createElement(r.a,{code:"\n\n  public class Weapon extends FighterDecorator {\n\n    ...\n\n    private Weapon(Fighter fighter, String weaponName) { ... }\n\n    ...\n\n    // inner builder\n\n    public static Weapon create(Consumer&lt;WeaponNameBuilder&gt; block) {\n      WeaponBuilder builder = new WeaponBuilder();\n      block.accept(builder);\n      builder.build();\n    }\n\n    public interface WeaponNameBuilder {\n      WeaponFighterBuilder name(String name);\n    }\n  \n    public interface WeaponFighterBuilder {\n      WeaponOptionsBuilder wielder(Fighter fighter);\n    }\n  \n    public interface WeaponOptionsBuilder {\n      WeaponCommandNameBuilder addCommand();\n      WeaponOptionsBuilder replaceActions();\n    }\n  \n    public interface WeaponCommandNameBuilder {\n      WeaponMoveBuilder withName(String name);\n    }\n  \n    public interface WeaponMoveBuilder {\n      WeaponOptionsBuilder andMove(Function&lt;Fighter, Move&gt; move);\n    }\n  \n    public static class WeaponBuilder implements WeaponNameBuilder, \n        WeaponFighterBuilder, WeaponOptionsBuilder,\n        WeaponCommandNameBuilder, WeaponMoveBuilder\n    {\n      private String weaponName;\n      private String commandName;\n      private Weapon weapon;\n\n      private WeaponBuilder() { }\n\n      @Override\n      public WeaponFighterBuilder name(String name) {\n        weaponName = name;\n        return this;\n      }\n\n      @Override\n      public WeaponOptionsBuilder wielder(Fighter fighter) {\n        weapon = new Weapon(fighter, weaponName);\n        return this;\n      }\n\n      @Override\n      public WeaponCommandNameBuilder addCommand() {\n        return this;\n      }\n\n      @Override\n      public WeaponMoveBuilder withName(String name) {\n        commandName = name;\n        return this;\n      }\n\n      @Override\n      public WeaponOptionsBuilder andMove(Function&lt;Fighter, Move&gt; move) {\n        WeaponCommand action = new WeaponCommand(commandName, move);\n        weapon.addAction(action);\n        return this;\n      }\n\n      @Override\n      public WeaponOptionsBuilder replaceActions() {\n        weapon.replaceActions = true;\n        return this;\n      }\n\n      private Weapon build() {\n        // validate at least 1 WeaponCommand\n        assert(!weapon.allActions().isEmpty());\n        weapon.equip();\n        return weapon;\n      }\n\n    }\n\n    class WeaponCommand implements ActionCommand {\n\n      ...\n\n      WeaponCommand(String name, Function&lt;Fighter, Move&gt; moveFunction) { ... }\n\n      @Override\n      public void execute() {\n        sendMove(moveFunction.apply(theFighter));\n      }\n\n\n    }\n\n  }\n\n"}),l.a.createElement("p",null,"I know. It's an overkill. But it's sure a good pattern to know!"),l.a.createElement(o.a,{prev:"lambdaLoaner",next:"lambdaMore"}))}}}]);
//# sourceMappingURL=14.e57af240.chunk.js.map