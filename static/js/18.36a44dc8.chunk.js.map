{"version":3,"sources":["components/common/Navigators.js","components/common/CodeSnippet.js","components/lambda/LambdaMore.js"],"names":["react__WEBPACK_IMPORTED_MODULE_0__","__webpack_require__","react__WEBPACK_IMPORTED_MODULE_0___default","n","react_router_dom__WEBPACK_IMPORTED_MODULE_1__","_const_Routes__WEBPACK_IMPORTED_MODULE_2__","getContent","pathKey","text","a","createElement","className","to","getRoute","path","Navigators","props","prev","next","keywords","annotations","parseAndTag","someCode","processed","matches","match","comments","Object","C_DataBox_Creative_code_workspace_KombatSim_ui_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__","forEach","comment","replace","processComments","annot","RegExp","openTag","processAnnotations","kw","processKeyword","CodeSnippet","preBlock","__html","code","react__WEBPACK_IMPORTED_MODULE_1___default","dangerouslySetInnerHTML","r","__webpack_exports__","_common_Navigators__WEBPACK_IMPORTED_MODULE_1__","react_router_dom__WEBPACK_IMPORTED_MODULE_2__","_const_Routes__WEBPACK_IMPORTED_MODULE_3__","_common_CodeSnippet__WEBPACK_IMPORTED_MODULE_4__","LambdaMore"],"mappings":"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","file":"static/js/18.36a44dc8.chunk.js","sourcesContent":["import React from 'react';\r\nimport {NavLink} from 'react-router-dom';\r\nimport PropTypes from 'prop-types';\r\nimport  {getRoute} from '../../const/Routes';\r\nimport './Navigators.css';\r\n\r\nconst Navigators = (props) => {\r\n  return (\r\n    <div className=\"navs\">\r\n      <span className=\"left\">\r\n        {getContent(props.prev, 'Previous')}\r\n      </span>\r\n      <span className=\"right\">\r\n        {getContent(props.next, 'Next')}\r\n      </span>\r\n    </div>\r\n  );\r\n};\r\n\r\nNavigators.propTypes = {\r\n  prev: PropTypes.string,\r\n  next: PropTypes.string\r\n};\r\n\r\nlet getContent = (pathKey, text) => {\r\n  if (pathKey) {\r\n    return <NavLink className=\"btn\" to={getRoute(pathKey).path}>{text}</NavLink>;\r\n  } else {\r\n    return <span className=\"btn-disabled\">{text}</span>;\r\n  }\r\n}\r\n\r\nexport default Navigators;","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport './CodeSnippet.css';\r\n\r\nconst keywordColor = 'yellow';\r\nconst keywords = [\r\n  'abstract', 'assert', 'boolean', 'break', 'byte', 'case', 'catch', 'char', 'class', 'const',\r\n  'do', 'double', 'else', 'enum', 'extends', 'final', 'finally', 'float', 'for', 'goto', 'if',\r\n  'implements', 'import', 'instanceof', 'int', 'interface', 'long', 'native', 'new', 'package',\r\n  'private', 'protected', 'public', 'return', 'short', 'static', 'strictfp', 'super', 'switch',\r\n  'synchronized', 'this', 'throw', 'throws', 'transient', 'try', 'void', 'volatile', 'while',\r\n  'true', 'false', 'null'\r\n];\r\nconst annotationColor = 'lightgray';\r\nconst annotations = ['Override'];\r\nconst commentColor = 'lightgray';\r\nconst closeTag = '</span>';\r\n\r\nconst processKeyword = (someCode) => {\r\n  let processed = someCode;\r\n  let openTag = '<span style=\"color: '+keywordColor+'; font-weight: bold;\">';\r\n  keywords.forEach(kw => \r\n    processed = processed.replace(\r\n                            new RegExp('\\\\b'+kw+'\\\\b', 'g'), \r\n                            openTag+kw+closeTag\r\n  ));\r\n  return processed;\r\n};\r\n\r\nconst processAnnotations = (someCode) => {\r\n  let processed = someCode;\r\n  let openTag = '<span style=\"color: '+annotationColor+'; font-weight: bold;\">';\r\n  annotations.forEach(annot => \r\n    processed = processed.replace(\r\n                            new RegExp('@\\\\b'+annot+'\\\\b', 'g'), \r\n                            openTag+'@'+annot+closeTag\r\n  ));\r\n  return processed;\r\n};\r\n\r\nconst processComments = (someCode) => {\r\n  let processed = someCode;\r\n  // picks out single line comments starting with // and enclosed in /* */, \r\n  // and multiline comments too\r\n  let regexp = /\\/\\*[\\s\\S]*?\\*\\/|([^:]|^)\\/\\/.*$/gm;\r\n  let matches = processed.match(regexp);\r\n  if (matches) {\r\n    let comments = [...matches];\r\n    let openTag = '<span style=\"color: '+commentColor+'; font-style: italic;\">';\r\n    comments.forEach(\r\n      comment => processed = processed.replace(comment, openTag+comment+closeTag)\r\n    );\r\n  }\r\n  return processed;\r\n};\r\n\r\nconst parseAndTag = (someCode) => {\r\n  someCode = processKeyword(someCode);\r\n  someCode = processAnnotations(someCode);\r\n  someCode = processComments(someCode);\r\n  return someCode;\r\n};\r\n\r\nconst CodeSnippet = (props) => {\r\n  let someCode = parseAndTag(props.code);\r\n  const preBlock = { __html: \"<pre>\" + someCode + \"</pre>\" };\r\n  return <div dangerouslySetInnerHTML={ preBlock }></div>;\r\n};\r\n\r\nCodeSnippet.propTypes = {\r\n  code: PropTypes.string\r\n};\r\n\r\nexport default CodeSnippet;","import React from 'react';\r\nimport Navigators from '../common/Navigators';\r\nimport {Link} from 'react-router-dom';\r\nimport  {getRoute} from '../../const/Routes';\r\nimport CodeSnippet from '../common/CodeSnippet';\r\n\r\nlet codeLambdaFactory = `\r\n\r\n  public final class AllDecorators {\r\n\r\n    public static final String SAMURAI = \"Samurai\";\r\n    ...\r\n\r\n    private static final Map&lt;String, Function&lt;Fighter, FighterDecorator&gt;&gt; decoratorMap \r\n              = new HashMap&lt;&gt;();\r\n\r\n    Function&lt;Fighter, FighterDecorator&gt; samuraiArmor = samurai -> \r\n        Armor.create( aSamuraiArmor -> \r\n            aSamuraiArmor\r\n              .toProtect(samurai)\r\n              .armorLife(30)\r\n              .damageRecutionMultiplier(0.3)\r\n              .enablePhysicalDamageReduction()\r\n        );\r\n\r\n    Function&lt;Fighter, FighterDecorator&gt; samuraiSword = samurai -> \r\n        Weapon.create( aSword -> \r\n            aSword\r\n              .name(\"Sword\")\r\n              .wielder(samurai)\r\n              .addCommand()\r\n              .withName(\"Slash\")\r\n              .andMove( f -> \r\n                  PhysicalDamage.create( damage -> \r\n                    damage.min(f.strength() * 0.4).max(f.strength() * 0.4 + 10)\r\n                  )\r\n              )\r\n              .addCommand()\r\n              .withName(\"Cut\")\r\n              .andMove( f -> \r\n                  PhysicalDamage.create( damage -> \r\n                    damage.min(f.strength() * 0.5).max(f.strength() * 0.5 + 20)\r\n                  )\r\n              )\r\n              .replaceActions()\r\n        );\r\n\r\n    Function&lt;Fighter, FighterDecorator&gt; samurai = samuraiArmor.andThen(samuraiSword);\r\n\r\n    ...\r\n\r\n    static {\r\n      decoratorMap.put(SAMURAI, samurai);\r\n      ...\r\n    }\r\n\r\n    private AllDecorators() { }\r\n\r\n    public static FighterDecorator getDecorator(String decorator, Fighter baseFighter) {\r\n      if (decoratorMap.contains(decorator)) {\r\n        return decoratorMap.get(decorator).apply(baseFighter);\r\n      }\r\n      throw new IllegalArgumentException(\"Invalid Decorator\");\r\n    }\r\n  }\r\n\r\n`;\r\n\r\nlet codeLambdaCombinatorAction = `\r\n\r\n  public class ActionSpell implements ActionCommand {\r\n    ...\r\n    Predicate&lt;Mage&gt; customCondition;\r\n\r\n    ...\r\n\r\n    @Override\r\n    public boolean canBeExecuted() {\r\n      return isReady() && mageHasMana() && customCondition.test(mage);\r\n    }\r\n\r\n  }\r\n\r\n`;\r\n\r\nlet codeLambdaCombinatorSpells = `\r\n\r\n  public final class Spells {\r\n\r\n    ...\r\n\r\n    private static Predicate&lt;Mage&gt; critical = \r\n          mage -> mage.currentLife() < (mage.maxLife() * 0.2);\r\n          \r\n    private static Function&lt;Mage, ActionSpell&gt; lifeSteal = mage -> \r\n        ActionSpell.create( action -> \r\n              action\r\n                .mage(mage)\r\n                .name(\"LifeSteal\")\r\n                ...\r\n                .executeCondition(critical) // mage about to die\r\n        );\r\n          \r\n    private static Function&lt;Mage, ActionSpell&gt; paralyze = mage -> \r\n        ActionSpell.create( action -> \r\n              action\r\n                .mage(mage)\r\n                .name(\"Paralyze\")\r\n                ...\r\n                .executeCondition( critical.negate() ) // mage healthy\r\n        );\r\n\r\n    ...\r\n\r\n  }\r\n\r\n`;\r\n\r\nconst LambdaMore = () => {\r\n  return (\r\n    <div className=\"main\">\r\n      <div className=\"pageTitle\">More Lambda</div>\r\n      <p>Let's check out a few other tricks.</p>\r\n      <div className=\"sectionTitle\">Lambda in Factory</div>\r\n      <p>\r\n        While the <Link to={getRoute('evolutionCreators').path}>FighterFactories</Link> follow the \r\n        conventional way, <code>AllDecorators</code> and <code>Spells</code> are two factories \r\n        which are built on the lambda concepts that we went through in the last few sections.\r\n      </p>\r\n      <CodeSnippet code={codeLambdaFactory} />\r\n      <p>\r\n        The above code takes a fighter and transforms him into a Samurai! Other decorators include \r\n        Ninja, Batman.\r\n      </p>\r\n      <p>\r\n        You might have noticed by now that this form of factory implementation is the result of \r\n        putting in the combined knowledge of the last three sections.\r\n      </p>\r\n      <p>\r\n        That's Functional programming is at its best! Combine, combine, combine!\r\n      </p>\r\n      <div className=\"sectionTitle\">Combinator Pattern</div>\r\n      <p>This sound just like what we discussed above. And It is!</p>\r\n      <p>\r\n        Combine primitives into more complex structures. That's <strong>Combinator Pattern</strong>.\r\n      </p>\r\n      <p>\r\n        A simple example. <code>ActionSpell.canbeExecuted()</code> takes in an additional custom \r\n        condition. All these conditions are checked and the result combined to deliver the verdict!\r\n      </p>\r\n      <CodeSnippet code={codeLambdaCombinatorAction} />\r\n      <p>Here in Spells factory, we construct 2 spells where we apply a custom condition.</p>\r\n      <p><em>Life Steal</em> spell can only be executed if the mage health is critically low.</p>\r\n      <p>\r\n        For the spell <em>Paralyze</em> it's otherwise (combines the original condition with a \r\n        negation).\r\n      </p>\r\n      <CodeSnippet code={codeLambdaCombinatorSpells} />\r\n      <p>\r\n        Simple example, limitless possibilites!\r\n      </p>\r\n      <Navigators prev=\"lambdaBuilder\" />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default LambdaMore;"],"sourceRoot":""}